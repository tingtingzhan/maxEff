---
title: "Additional Predictor with Maximum Effect Size"
author: Tingting Zhan
date: "`r format(Sys.time(), 'Last updated %d %B, %Y')`"
format: 
  html:
    page-layout: full
    html-math-method: katex
toc: true
toc-location: left
toc-depth: 4
toc-title: ''
editor: source
bibliography: maxEff.bib
knitr:
  opts_chunk: 
    collapse: true
    comment: "#" 
vignette: >
  %\VignetteIndexEntry{intro}
  %\VignetteEngine{quarto::html}
  %\VignetteEncoding{UTF-8}
---


# Introduction

This vignette provides examples of using `R` packages

-   **`groupedHyperframe`**, @groupedHyperframe, [CRAN](https://cran.r-project.org/package=groupedHyperframe), [Github](https://github.com/tingtingzhan/groupedHyperframe), [RPubs](https://rpubs.com/tingtingzhan/groupedHyperframe)
-   **`maxEff`**, @maxEff, [CRAN](https://cran.r-project.org/package=maxEff), [Github](https://github.com/tingtingzhan/maxEff), [RPubs](https://rpubs.com/tingtingzhan/maxEff)

to select one from many `numeric` predictors for a regression model, to ensure that the additional predictor has the maximum effect size.

R terminology might be different from that of mathematics and statistics. Please refer to Appendix @sec-terms for explanation and reference of the terms and abbreviations used in this vignette.

Package **`maxEff`** `Imports` packages

-   `r '\U1f5dd'` **`caret`** [@caret, v`r packageVersion('caret')`], for data partition
-   `r '\U1f5dd'` **`groupedHyperframe`** (dev v`r packageVersion('groupedHyperframe')`), key dependency, for function `t.vectorlist()`
-   **`parallel`** shipped with `r R.version$version.string`, for parallel computing
-   `r '\U1f5dd'` **`rpart`** [@rpart, v`r packageVersion('rpart')`], key dependency, for recursive partitioning
-   `r '\U1f5dd'` **`spatstat.geom`** [@spatstat15, dev v`r packageVersion('spatstat.geom')`], key dependency, for `hyperframe` data structure

Package **`maxEff`** `Suggests` packages

-   `r '\U1f5dd'` **`survival`** [@survival, v`r packageVersion('survival')`], key suggest, <!--for function `survival:::as.data.frame.Surv()`--> to help `hyperframe` understand `Surv` object

Package **`groupedHyperframe`** dependencies are outlined in its separate vignette ([CRAN](https://cran.r-project.org/package=groupedHyperframe/vignettes/groupedHyperframe.html), [RPubs](https://rpubs.com/tingtingzhan/groupedHyperframe)).

## Prerequisite

Packages **`groupedHyperframe`** and **`maxEff`** require R version 4.5.0 (released 2025-04-11) or higher ([macOS](https://cran.r-project.org/bin/macosx/), [Windows](https://cran.r-project.org/bin/windows/base/)). An Integrated Development Environment (IDE), e.g., [RStudio](https://posit.co/download/rstudio-desktop/) or [Positron](https://positron.posit.co/download.html), is not required, but highly recommended. This vignette is created under `r R.version$version.string` using packages **`knitr`** [@knitr, v`r packageVersion('knitr')`], **`quarto`** [@quarto, v`r packageVersion('quarto')` with [Quarto](https://quarto.org/docs/get-started/) v`r quarto::quarto_version()`] and **`rmarkdown`** [@rmarkdown, v`r packageVersion('rmarkdown')`].

```{r}
#| code-fold: true
#| code-summary: "Environment on author's computer"
Sys.info()[c('sysname', 'release', 'machine')]
R.version
```

Experimental (and maybe unstable) features are released *extremely frequently* to [Github](https://github.com/tingtingzhan/maxEff). [Active developers should use the Github version; suggestions and bug reports are welcome!]{style="background-color: #FFFF00"} Stable releases to [CRAN](https://CRAN.R-project.org/package=maxEff) are typically updated every 2 to 3 months, or when the authors have an upcoming manuscript in the peer-reviewing process.

```{r}
#| eval: false
remotes::install_github('tingtingzhan/groupedHyperframe')
remotes::install_github('tingtingzhan/maxEff')
```

```{r}
#| eval: false
#| code-fold: true
#| code-summary: "Developers, do NOT use the CRAN version!"
utils::install.packages('groupedHyperframe') # Developers, do NOT use!!
utils::install.packages('maxEff') # Developers, do NOT use!!
```

## Getting Started

Examples in this vignette require that the `search` path has

```{r setup}
library(maxEff)
library(groupedHyperframe)
library(survival)
```

As of package **`spatstat.explore`** [@spatstat15, v`r packageVersion('spatstat.explore')`] and **`pROC`** [@pROC, v`r packageVersion('pROC')`], we have a function name clash between `spatstat.explore::plot.roc()` and `pROC::plot.roc()` when loading both packages **`groupedHyperframe`** (which `Imports` package **`spatstat.explore`**) and **`maxEff`** (which `Imports` package **`caret`** which `Imports` package **`pROC`**). This function name clash is potentially hazardous as the `S3` classes `spatstat.explore::roc` and `pROC::roc` are totally different.

```{r}
#| echo: false
#options(mc.cores = 1L) # for CRAN submission
```

## Acknowledgement

This work is supported by National Institutes of Health, U.S. Department of Health and Human Services grants

-   R01CA222847 ([I. Chervoneva](https://orcid.org/0000-0002-9104-4505), [T. Zhan](https://orcid.org/0000-0001-9971-4844), and [H. Rui](https://orcid.org/0000-0002-8778-261X))
-   R01CA253977 (H. Rui and I. Chervoneva).

# Examples

## Non-Spatial Example

[Point user to `groupedHyperframe` vignette, section *Publications*.]{style="background-color: yellow"}

[Copy language from `hyper.gam` vignette, section *Quantile Index*, subsection *Compute Aggregated Quantiles*.]{style="background-color: yellow"}

```{r}
Ki67q = groupedHyperframe::Ki67 |>
  within.data.frame(expr = {
    x = y = NULL # remove x- and y-coords for non-spatial application
  }) |>
  as.groupedHyperframe(group = ~ patientID/tissueID) |>
  aggregate_quantile(by = ~ patientID, probs = seq.int(from = .01, to = .99, by = .01))
```

```{r}
#| code-fold: true
#| code-summary: 'A `hyperframe` *`Ki67q`* with aggregated quantiles'
Ki67q |>
  head()
```

## Spatial Example

[Compose some English.]{style="background-color: yellow"}

[And share with `hyper.gam` vignette, section *Spatial Index*.]{style="background-color: yellow"}

```{r}
#| eval: false
Ki67s = groupedHyperframe::Ki67 |>
  grouped_ppp(formula = logKi67 ~ . | patientID/tissueID) |>
  Emark_(r = seq.int(from = 0, to = 100)) |>
  aggregate_fv(by = ~ patientID)
```

```{r}
#| eval: false
#| code-fold: true
#| code-summary: 'A `hyperframe` *`Ki67s`* with aggregated `Emark`'
Ki67s |>
  head()
```

# Data Partition

Partition into a training (80%) and test (20%) set.

```{r}
set.seed(32); id = sample.int(n = nrow(Ki67q), size = nrow(Ki67q)*.8) |> sort.int()
s0 = Ki67q[id, , drop = FALSE] # training set
s1 = Ki67q[-id, , drop = FALSE] # test set
```

# Starting Model

Let's consider a starting model of endpoint `PFS` with predictor `Tstage` on the training set `s0`. As of package **`spatstat.geom`** v`r packageVersion('spatstat.geom')`, function `spatstat.geom::as.data.frame.hyperframe()` warns on hypercolumns that aren't able to be converted to a `data.frame`. Therefore, user should use `suppressWarnings()` or set `#| warning: false` in R markdown codeâ€“chunk.

```{r}
#| warning: false
m0 = coxph(PFS ~ Tstage, data = s0)
```

```{r}
#| code-fold: true
#| code-summary: Starting `coxph` model *`m0`*
summary(m0)
```

# Adding `numeric` Predictor

```{r}
a0 = m0 |>
  add_numeric(x = ~ logKi67.quantile) |>
  sort_by(y = abs(effsize)) |>
  head(n = 2L)
```

The pipeline above consists of three steps

First, function `add_numeric()` 

-   considers each "slice" of the `numeric`-hypercolumn *`logKi67.quantile`* as an additional `numeric` predictor.  Users are encourage to read the package **`groupedHyperframe`** [vignette](https://rpubs.com/tingtingzhan/groupedHyperframe), Appendix Section *On `anylist`* for more details;
-   `update`s the starting model *`m0`* with each one of the additional `numeric` predictors, respectively;
-   returns an `'add_numeric'` object, which inherits from class `'add_'`.  This is a `listof` objects with internal class `'add_numeric_'` (see Appendix @sec-add_numeric_). 

Second, the `S3` method dispatch `sort_by.add_()` sorts the input by the `abs`olute values of the regression coefficients (i.e., effect size `effsize`) of the additional `numeric` predictors.

Lastly, the `S3` method dispatch `utils:::head.default()` chooses the top `n` element from the input.

The `S3` method dispatch `print.add_numeric()` displays the `call`s to the selected `numeric` predictors.  Developers may pass these calls to parameter `ee` of function `spatstat.geom::with.hyperframe()` for further analysis.

```{r}
a0
```

```{r}
#| code-fold: true
#| code-summary: 'Developers: retrieve the 1st selected `numeric` predictor'
s0 |>
  with(ee = a0[[1L]]) |> # ?spatstat.geom::with.hyperframe
  head()
```

```{r}
#| code-fold: true
#| code-summary: 'Developers: retrieve the 2nd selected `numeric` predictor'
s0 |>
  with(ee = a0[[2L]]) |> # ?spatstat.geom::with.hyperframe
  head()
```

The S3 method dispatch `predict.add_numeric()` applies the starting model structure in *`m0`*, as well as the additional `numeric` predictors selected by *`a0`*, on the test set *`s1`*.

```{r}
a0 |> 
  predict(newdata = s1)
```



# Adding `logical` Predictor

## Naive Practice

Function `add_dummy()` partitions each additional `numeric` predictor into a logical variable using function `node1()`, and `update`s the starting model by adding in each of the dichotomized `logical` predictor. Function `add_dummy()` returns an `'add_dummy'` object, which is a `listof` `node1` objects (see Appendix @sec-node1).

The `S3` method dispatch `subset.add_dummy()` subsets the the `'add_dummy'` object by the balance of partition of the additional predictor.

The `S3` method dispatch `sort_by.add_()` sorts the `'add_dummy'` object by the `abs`olute value of regression coefficient (i.e., effect size) of the additional logical predictor.

The `S3` method dispatch `utils:::head.default()` chooses the top `n` element from the object returned from the previous step.

```{r}
#| label: add_dummy
b0 = m0 |>
  add_dummy(x = ~ logKi67.quantile) |>
  subset(subset = p1 > .05 & p1 < .95) |> 
  # need a [unique.add_dummy()] !!!!
  sort_by(y = abs(effsize)) |>
  head(n = 2L)
b0
```

To find the selected additional logical predictor,

```{r}
Ki67q |> 
  with(ee = formals(b0[[1L]])$newx) |> # ?spatstat.geom::with.hyperframe
  b0[[1L]]() |>
  head(n = 20L)
```

```{r}
Ki67q |> 
  with(ee = formals(b0[[2L]])$newx) |> # ?spatstat.geom::with.hyperframe
  b0[[2L]]() |>
  head(n = 20L)
```

The S3 method generic `predict.add_dummy()` uses model `b0` on the test set `s1`.

```{r}
b0[1L] |> predict(newdata = s1)
```

## via Repeated Partitions

Function `add_dummy_partition()` partitions each additional `numeric` predictor into a `logical` variable in the following steps.

1.  Generate multiple, i.e., repeated, partitions.
2.  For each partition, create a dichotomizing rule (via function `node1()`) on the training set. Apply this dichotomizing rule on the test set and obtain the estimated regression coefficient (i.e., effect size) of the additional `logical` predictor.
3.  Among all partitions, select the one with median effect size of the additional `logical` predictor.

Function `add_dummy_partition()` also returns an `'add_dummy'` object.

```{r}
#| label: add_dummy_partition
set.seed(83); c0 = m0 |> 
  add_dummy_partition(~ logKi67.quantile, times = 20L) |>
  subset(subset = p1 > .15 & p1 < .85) |>
  sort_by(y = abs(effsize), decreasing = TRUE) |>
  head(n = 2L)
c0
```

```{r}
c0[1L] |> predict(newdata = s1)
```

# Appendix

## `node1()` {#sec-node1}

Function `node1()` dichotomizes a single `numeric` `vector` based on the first node of a recursive partitioning and regression tree `rpart.object` from package **`rpart`** [@rpart]. In this section, we illustrate

-   the use of function `node1()`, and
-   the `S3` method dispatches to the class `'node1'`

using data examples from package **`rpart`**. To keep the user's `search` path simple and clean, we intentionally call functions in package **`rpart`** and **`survival`** [@survival] with explicit namespace, instead of using `library()` or `require()`.

Data example `rpart::stagec` contains 146 patients with stage C prostate cancer. 

```{r}
data(stagec, package = 'rpart')
stagec0 = stagec[1:140,] # training set
stagec1 = stagec[-(1:140),] # test set
```

We create a recursive partitioning model of the numeric variable *`age`* with the endpoint of progression-free survival among the first 140 patients of the training set *`stagec0`*.  In the following call to function `rpart::rpart()`,

-   parameter `cp = .Machine$double.eps` ensures at least one node/split of the partitioning tree.
-   parameter `maxdepth = 2L` reduces the computation cost as we need only the first node. 

```{r}
#| label: rpart
rp0 = rpart::rpart(
  formula = survival::Surv(pgtime, pgstat) ~ age, 
  data = stagec0, 
  cp = .Machine$double.eps,
  maxdepth = 2L
)
```


```{r}
#| code-fold: true
#| code-summary: 'Recursive partitioning tree *`rp0`*'
rp0
```

Function `node1()` creates a **dichotomizing rule** of the numeric variable *`age`* based on the first node in the tree *`rp0`*. Function `node1()` returns an object of class `'node1'`, which `inherits` from the class `'function'`.  The `name` of the numeric variable, e.g., *`age`*, is stored as the `formals` argument of parameter *`newx`*.

```{r}
#| label: node1
fn0 = rp0 |>
  node1()
```

Dichotomizing rule *`fn0`* should be used as any R `function`.

```{r}
set.seed(35); rnorm(6, mean = 53.5) |> 
  fn0()
```


The `S3` method dispatch `base::print.function()` displays the dichomizing rule *`fn0`*,

```{r}
fn0
```

The `S3` method dispatch `labels.node1()` returns a human-friendly `character` text to describe the dichotomizing rule.

```{r}
fn0 |> 
  labels()
```

The `S3` method dispatch `predict.node1()` dichotomize the numeric variable *`age`* in the test set *`stagec1`*, using the dichotomizing rule *`fn0`* determined by the training set *`stagec0`*.

```{r}
data.frame(
  stagec1$age,
  Dichotomized = fn0 |> predict(newdata = stagec1),
  check.names = FALSE
)
```

Developers may obtain the `numeric` cutoff value of the dichotomizing rule *`fn0`*.

```{r}
#| code-fold: true
#| code-summary: 'R code: subject to change!'
fn0 |> get_cutoff()
```

## `statusPartition()` {#sec-statusPartition}

Function `statusPartition()` partitions stratified a `survival::Surv` object based on its survival status, to avoid the situation that a Cox proportional hazards model `survival::coxph()` in one or more of the partitioned data set being degenerate due to the fact that all subjects in that partition being censored. 

```{r}
capacitor_failure = survival::capacitor |> 
  with(expr = Surv(time, status))
```

```{r}
#| code-fold: true
#| code-summary: '`Surv` object *`capacitor_failure`*'
capacitor_failure
```


```{r}
#| label: statusPartition
set.seed(15); id = capacitor_failure |>
  statusPartition(times = 1L, p = .5)
table(capacitor_failure[id[[1L]], 2L]) / table(capacitor_failure[,2L]) # balanced by survival status
```

Function `statusPartition()` is an extension of the very popular function `caret::createDataPartition()`, which stratifies a `Surv` object by the `quantile`s of its survival time (as of package **`caret`** v`r packageVersion('caret')`).

```{r}
#| code-fold: true
#| code-summary: '`caret::createDataPartition()`: *not* balanced by survival status'
set.seed(15); id0 = capacitor_failure |>
  caret::createDataPartition(times = 1L, p = .5)
table(capacitor_failure[id0[[1L]], 2L]) / table(capacitor_failure[,2L])
```

## Internal Class `'add_numeric_'` {#sec-add_numeric_}

ðŸš§ This section is under construction.


## Terms & Abbreviations {#sec-terms}

| Term / Abbreviation | Description |
|------------------------------------|------------------------------------|
| CRAN, R | The Comprehensive R Archive Network, <https://cran.r-project.org> |
| [`|>`](https://search.r-project.org/R/refmans/base/html/pipeOp.html) | Forward pipe operator introduced since R 4.1.0 |
| [`abs`](https://search.r-project.org/R/refmans/base/html/MathFun.html) | Absolute value |
| [`coxph`](https://search.r-project.org/CRAN/refmans/survival/html/coxph.html) | Cox proportional hazards model |
| [`createDataPartition`](https://search.r-project.org/CRAN/refmans/caret/html/createDataPartition.html) | Test vs. training data set partition, from package **`caret`** [@caret] |
| [`factor`](https://search.r-project.org/R/refmans/base/html/factor.html) | Factor, or categorical variable |
| [`formals`](https://search.r-project.org/R/refmans/base/html/formals.html) | Formal arguments |
| [`function`](https://search.r-project.org/R/refmans/base/html/function.html) | R function |
| [`groupedHyperframe`](https://CRAN.R-project.org/package=groupedHyperframe) | Grouped hyper data frame |
| [`head`](https://search.r-project.org/R/refmans/utils/html/head.html) | First parts of an object |
| `hypercolumns`, [`hyperframe`](https://search.r-project.org/CRAN/refmans/spatstat.geom/html/hyperframe.html) | (Hyper columns of) hyper data frame, from package **`spatstat.geom`** [@spatstat05] |
| [`labels`](https://search.r-project.org/R/refmans/base/html/labels.html) | Labels from object |
| [`levels`](https://search.r-project.org/R/refmans/base/html/levels.html) | Levels of a [`factor`](https://search.r-project.org/R/refmans/base/html/factor.html) |
| [`listof`](https://search.r-project.org/R/refmans/stats/html/listof.html) | List of objects |
| `logistic` | Logistic regression model, `stats::glm(., family = binomial(\'logit\'))` |
| [`matrix`](https://search.r-project.org/R/refmans/base/html/matrix.html) | Matrix |
| `PFS` | Progression/recurrence free survival, <https://en.wikipedia.org/wiki/Progression-free_survival> |
| [`predict`](https://search.r-project.org/R/refmans/stats/html/predict.html) | Model prediction, `maxEff::predict.add_numeric`; `maxEff::predict.add_dummy` |
| [`quantile`](https://search.r-project.org/R/refmans/stats/html/quantile.html) | Quantile |
| [`rpart`](https://search.r-project.org/CRAN/refmans/rpart/html/rpart.html), [`rpart.object`](https://search.r-project.org/CRAN/refmans/rpart/html/rpart.object.html), `node` | Recursive partitioning and regression trees |
| `S3`, `generic`, [`methods`](https://search.r-project.org/R/refmans/utils/html/methods.html) | `S3` object oriented system, [`UseMethod`](https://search.r-project.org/R/refmans/base/html/UseMethod.html); [`getS3method`](https://search.r-project.org/R/refmans/utils/html/getS3method.html); <https://adv-r.hadley.nz/s3.html> |
| `S4`, `generic`, `methods` | `S4` object oriented system, [`isS4`](https://search.r-project.org/R/refmans/base/html/isS4.html); [`setClass`](https://search.r-project.org/R/refmans/methods/html/setClass.html); [`setMethod`](https://search.r-project.org/R/refmans/methods/html/setMethod.html); [`getMethod`](https://search.r-project.org/R/refmans/methods/html/getMethod.html); <https://adv-r.hadley.nz/s4.html> |
| [`sort_by`](https://search.r-project.org/R/refmans/base/html/sort_by.html) | Sort an object by some criterion, `maxEff::sort_by.add_` |
| [`subset`](https://search.r-project.org/R/refmans/base/html/subset.html) | Subsets of object by conditions, `maxEff::subset.add_dummy` |
| [`suppressWarnings`](https://search.r-project.org/R/refmans/base/html/warning.html) | Suppress warning messages |
| [`Surv`](https://search.r-project.org/CRAN/refmans/survival/html/Surv.html) | Survival, i.e., time-to-event, object, from package **`survival`** [@survival] |
| [`update`](https://search.r-project.org/R/refmans/stats/html/update.html) | Update and re-fit a model call |

# References

::: {#refs}
:::
